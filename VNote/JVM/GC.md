# GC

**判断为垃圾的标准**
判断为垃圾的标准就是看该对象有没有被其他对象引用。
引用可以分为： 强引用、弱引用、软引用、虚引用等（建议直接看《深入理解java虚拟机》）

**如何判定有没有被其他对象引用：**

1. 引用计数算法（主流jvm未采用此种算法）
每个对象实例都有一个引用计数器；对象被引用时+1，完成引用-1；引用计数为0的对象实例可被认为是垃圾。
优点：执行效率高，程序执行受影响小。
缺点：无法检测出循环引用（两个对象实例互相引用），导致内存泄漏。
2. 可达性分析算法
通过判断对象的引用链是否可达来判断对象是否可以被回收。（~ 图论相关知识）
<br/>

## 垃圾回收算法

* **标记清除算法**
标记：从根集合进行扫描，对存活对象进行标记。
清除：对堆内存进行从头到尾线性遍历，回收不可达对象占用的内存；遍历完成后清除可达对象的标记，进行下一次标记。
缺点：容易产生大量内存碎片，新生对象可能会因为没有足够大的连续内存空间而产生内存溢出错误。

* **复制算法**
复制算法分为对象面和空闲面；
对象在对象面创建，存活的对象从对象面复制到空闲面；
最后将对象面所有对象清除。
优点：一次回收整个半区，解决内存碎片问题；顺序分配内存，简单高效。
缺点：当存活对象较多时，因为需要复制大量对象实例，效率低。
适用场景：对象存活率低的场景，如新生代的survivor区。新生代对象存活率一般为10%，实际需要移动的对象实例较少，采用复制算法不会明显降低效率。

* **标记整理算法**
标记：从根集合进行扫描，对存活对象进行标记。
整理：移动所有存活对象，且按照内存地址次序一次排列，然后将末端内存地址以后的内存全部回收。
优点：避免内存碎片问题；不需要设置两块内存区域进行互换。
缺点：标记整理算法是在标记清除算法的基础上对对象进行移动，因此成本更高。
适用场景：适用于内存存活率很高的场景，如老年代的回收就是采用该种算法。

* **分代回收算法**
按照对象生命周期的不同划分区域，在不同区域采用该区域效率最高的垃圾收集算法，提高JVM的垃圾回收效率；
<br/>

## 分代收集 GC 的分类

* **Minor GC**：**年轻代**中发生，空间采用复制算法。
* **Full GC**：**老年代**中发生。老年代GC往往会伴随年轻代GC，因此称为 Full GC。

### 年轻代
绝大多数新生对象都不会存活，需要尽快回收垃圾。
进一步划分：Eden区、Survivor From区、Survivor To区（默认空间大小比例 8:1:1）；
新生对象从一般从 Eden 区产生，如果对象太大放不下，则放在老年代；
两个Survivor区的位置不固定，会随着GC进行而相互转换。（我觉得有点像 Git 的版本控制指针）
新生代进行一次垃圾回收时，将 Eden 区和 Survivor From 区存活的对象复制到 Survivor To 区

**每一次 Minor GC 所做的事：**

* Eden 区存活对象 ＋ Survivor From 区存活的的对象被复制到 Survivor To 区；
* 清空 Eden 和 Survivor From；
* Survivor From 和 Survivor To 位置交换，每次 Minor GC 后 Survivor To 区都是空的。
* 每次 Minor GC ，存活对象的年龄都会 +1；

**Minor GC 详细过程：（下面用“移动”代表“复制+删除”两个过程）**

* Minor GC 前：
    Sursivor From 和 Sursivor To 区都是空的。
* 第 1 次 Minor GC：
    对象从 Eden 区（假设能放得下）创建，新生对象年龄是 0，当 Eden 区空间满时，Eden 区存活的对象移动到 Sursivor To 区
    （一开始 From 区为空，只有 Eden 区存在对象），存活对象年龄 +1，From 区和 To 区位置交换；
* 第 2 次 Minor GC：
    Eden 区存活的对象和 Survivor From 存活的对象移动到 Sursivor To 区，所有存活的对象年龄 +1，From 区和 To 区位置交换；
* ...
* 第 n 次 Minor GC：
    当存活对象年龄达到设置值（默认值 15，可通过参数 -XX:MaxTenuringThreshold 修改）时，将从新生代移到老年代；

**年轻代对象什么情况下才能晋升到老年代：**
* 经过一定次数（默认 15）的 Minor GC 依然存活；
* Survivor 区放不下的对象；
* 新生成的大对象（通过参数 -XX:+PretenuerSizeThreshold 修改）

### 老年代
存放生命周期较长的对象，年轻代空间约等于1/3堆，老年代空间约等于2/3堆；
采用标记清理算法和标记整理算法。
老年代中发生 Full GC，Full GC 比 Minor GC 慢，但执行频率低；

**触发 Full GC 条件：**
* 老年代空间不足；
* 永久代空间不足（jdk7 及以下）；
* CMS GC 时出现 promotion failed，concurrent mode failed；
* Minor GC 晋升到老年代的平均大小大于老年代的剩余空间；
* 调用 System.gc()；（可以加快 GC，但JVM 不一定会立即执行 GC，具体执行时间由 JVM 自己管理）;
* 使用 RMI 来进行 RPC 或管理的 JDK 应用，每小时执行 1 次 Full GC；
<br/>

## GC 优化

**概念：Stop-the-world、Safepoint**

* Stop-the-world
由于 JVM 执行 GC 而停止应用程序执行；
在任何一种 GC 算法中都可能发生；
多数 GC 优化通过减少 Stop-the-world 发生的时间来提高程序性能。

* Safepoint
分析过程中对象引用关系不会发生变化的点（快照）；
产生 Safepoint 的地方：方法跳转、循环跳转、异常跳转等；
Safepoint 的数量要适中。

**JVM 的运行模式**

JVM 有两种运行模式 **Server** 与 **Client**。Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多。这是因为 Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；而 Client 模式启动的 JVM 采用的是轻量级的虚拟机。
查看当前 JVM 运行模式：java -version

### 常见的垃圾收集器

**年轻代常见的垃圾收集器**

* Serial 收集器（-XX:+UseSerialGC，采用复制算法）
Java 历史最悠久、最基本的收集器；
单线程收集，进行垃圾收集时时必须暂停其他所有工作线程，直至收集结束；
简单高效，是 Client 模式下默认的年轻代收集器；

* ParNew 收集器（-XX:+UseParNewGC，采用复制算法）
多线程收集，其余行为特点和 Serial 收集器一样；
Server 模式下年轻代首选的垃圾收集器；
由于多线程切换开销。单核执行效率不如 Serial，在多核下执行才有优势；
除了 Serial 外，目前只有 ParNew 收集器能与 CMS 收集器配合工作；

* Parallel Scavenge 收集器（-XX:+UseParallelGC，采用复制算法）
概念：吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间）
比起关注用户线程停顿时间，更关注系统吞吐量；
在多核下执行才有优势，是 Server 模式下年轻代默认的收集器；

**老年代常见的垃圾收集器**

* Serial Old 收集器（-XX:UseSerialOldGC，采用标记整理算法）
简单高效，是 Client 模式下默认的老年代收集器；

* Parallel Old 收集器（-XX:+UserParalledOldGC，采用标记整理算法）
多线程，吞吐量优先；

* CMS 收集器（-XX:+UseConcMarkSweepGC，采用标记清除算法）
垃圾回收线程几乎能与工作线程同时工作，缩短了停顿时间，但是依然不能避免 Stop-the-world；
在老年代存在较多寿命较长的对象，采用 CMS 收集器更有优势；

* jdk11 ZGC（了解）









