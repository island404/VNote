# GC

## 判断为垃圾的标准

判断为垃圾的标准就是看该对象有没有被其他对象引用。

    引用又可以分为： 强引用、弱引用、软引用、虚引用等（建议直接看《深入理解java虚拟机》）

如何判定有没有被其他对象引用：

    1. 引用计数算法（主流jvm未采用此种算法）
        每个对象实例都有一个引用计数器；对象被引用时+1，完成引用-1；引用计数为0的对象实例可被认为是垃圾。
	    优点：执行效率高，程序执行受影响小。
	    缺点：无法检测出循环引用（两个对象实例互相引用），导致内存泄漏。
    2. 可达性分析算法
	    通过判断对象的引用链是否可达来判断对象是否可以被回收。（~ 图论相关知识）

## 垃圾回收算法

标记清除算法

    标记：从根集合进行扫描，对存活对象进行标记。
	清除：对堆内存进行从头到尾线性遍历，回收不可达对象占用的内存；遍历完成后清除可达对象的标记，进行下一次标记。
	标记清除算法缺点：容易产生大量内存碎片，新生对象可能会因为没有足够大的连续内存空间而产生内存溢出错误。

复制算法

	复制算法分为对象面和空闲面；
	对象在对象面创建，存活的对象从对象面复制到空闲面；
	最后将对象面所有对象清除。
	优点：一次回收整个半区，解决内存碎片问题；顺序分配内存，简单高效。
	缺点：当存活对象较多时，因为需要复制大量对象实例，效率低。
	适用场景：
		对象存活率低的场景，比如新生代的两个survivor区就是使用该算法。
		新生代对象存活率一般为10%，实际需要移动的对象实例较少，采用复制算法不会明显降低效率。

标记整理算法

	标记：从根集合进行扫描，对存活对象进行标记。
	整理：移动所有存活对象，且按照内存地址次序一次排列，然后将末端内存地址以后的内存全部回收。
	优点：避免内存碎片问题；不需要设置两块内存区域进行互换。
	适用场景：
		标记整理算法是在标记清除算法的基础上对对象进行移动，因此成本更高，但是解决了内存碎片问题。
		适用于内存存活率很高的场景，比如老年代的回收就是采用该种算法。

分代回收算法

	按照对象生命周期的不同划分区域，在不同区域采用该区域效率最高的垃圾收集算法，提高JVM的垃圾回收效率；

## 分代收集 GC 的分类

* **Minor GC**：**年轻代**中发生，空间采用复制算法。
* **Full GC**：**老年代**中发生。老年代GC往往会伴随年轻代GC，因此称为 Full GC。

**年轻代**

	绝大多数新生对象都不会存活，需要尽快回收垃圾。
	进一步划分：Eden区、Survivor From区、Survivor To区（默认空间大小比例 8:1:1）；
	新生对象从一般从 Eden 区产生，如果对象太大放不下，则放在老年代；
	两个Survivor区的位置不固定，会随着GC进行而相互转换。（我觉得有点像 Git 的版本控制指针）
	新生代进行一次垃圾回收时，将 Eden 区和 Survivor From 区存活的对象复制到 Survivor To 区

每一次 Minor GC 所做的事：

    (1) Eden 区存活对象 ＋ Survivor From 区存活的的对象被复制到 Survivor To 区；
    (2) 清空 Eden 和 Survivor From；
    (3) Survivor From 和 Survivor To 位置交换，每次 Minor GC 后 Survivor To 区都是空的。
    (4) 每次 Minor GC ，存活对象的年龄都会 +1；

Minor GC 详细过程：（下面用“移动”代表“复制+删除”两个过程）

    Minor GC 前：
        Sursivor From 和 Sursivor To 区都是空的。
    第 1 次 Minor GC：
        对象从 Eden 区（假设能放得下）创建，新生对象年龄是 0，当 Eden 区空间满时，Eden 区存活的对象移动到 Sursivor To 区（一开始 From 区为空，只有 Eden 区存在对象），存活对象年龄 +1，From 区和 To 区位置交换；
    第 2 次 Minor GC：
        Eden 区存活的对象和 Survivor From 存活的对象移动到 Sursivor To 区，所有存活的对象年龄 +1，From 区和 To 区位置交换；
    ...
    第 n 次 Minor GC：
        当存活对象年龄达到设置值（默认值 15，可通过参数 -XX:MaxTenuringThreshold 修改）时，将从新生代移到老年代；

年轻代对象什么情况下才能晋升到老年代：

	经过一定次数（默认 15）的 Minor GC 依然存活；
	Survivor 区放不下的对象；
	新生成的大对象（通过参数 -XX:+PretenuerSizeThreshold 修改）

**老年代**

	存放生命周期较长的对象；
	采用标记清理算法和标记整理算法。
	老年代中发生 Full GC，Full GC 比 Minor GC 慢，但执行频率低；

触发 Full GC 条件：

* 老年代空间不足；
* 永久代空间不足（jdk7 及以下）；
* CMS GC 时出现 promotion failed，concurrent mode failed；
* Minor GC 晋升到老年代的平均大小大于老年代的剩余空间；
* 调用 System.gc()；（可以加快 GC，但JVM 不一定会立即执行 GC，具体执行时间由 JVM 自己管理）;
* 使用 RMI 来进行 RPC 或管理的 JDK 应用，每小时执行 1 次 Full GC；